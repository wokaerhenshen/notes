1.DDD:
如果要用一两句话描述DDD，那就是：

“领域驱动设计，就是以业务领域中的概念和机制为蓝本，用面向对象的方法设计软件系统的领域层。系统中的其余各层都以领域层为中心依次构建。”

下面分别解释。

###1、以业务领域中的概念和机制为蓝本。

作为企业应用软件开发人员，最大的挑战，同时也是最大的乐趣的就是：我们是为别人的业务领域编写软件。为了能够为业务领域（问题域）编写正确的、适用的软件，我们必须深入理解现实业务领域的关键概念、业务规则和运行机制。做不到这一点，我们的软件必然是错漏百出的。我们通过学习、研究和探索业务领域，然后用一个概念模型来表达我们对业务领域的理解，这个过程叫做“领域建模”，形成的模型叫做“领域模型”，领域模型记录了业务领域中的关键实体、实体之间的关联、以及业务实体之间如何相互协作以实现业务功能。在企业应用开发的所有活动中，领域建模是最为关键的活动，在很大程度上决定了软件的成败。

好。现在我们对业务领域（问题域）有了深入的理解之后，如何来设计和实现软件（解决方案域）？当然答案是：参照领域模型来实现。领域模型中的概念和机制是业务领域中一代代业务专家和从业者智慧的结晶，想我们自己能够有多高深的道行，能够另起炉灶打造一套不同的概念和机制？所以模仿问题领域的模型来构造我们的软件解决方案，是最正确、最可行、最省力、最可验证的路径。

以银行借记卡为例，问题域中有“账户”这个概念，解决方案中就设计“账户”这个类对应。问题域中的账户能够转账给另一个账户，软件中的账户类就通过在账户类中定义transferFundTo()方法对应这个行为。问题域中的转账不允许超过账户余额，软件账户类中的transferFundTo()方法也必须保证这一点。

###2、用面向对象的方法设计软件系统的领域层。

这一点是DDD和CRUD（以数据库为中心的增删改查）外观上最明显的差别所在。在CRUD范式中，领域类的实例不是一个对象，而是一种数据结构，它对应于数据库表中的一行记录，而不是对应于业务领域中的一个实体。它承载了其他软件类需要使用的数据，而本身没有定义任何行为。Martin Fowler等人将这些所谓领域对象称之为“贫血”对象，其实更准确的称呼是“伪对象”——披上对象外衣的数据结构。

在DDD范式中，领域对象是真正的对象，同时具有状态（数据）和行为（方法）。它对应于业务领域中一个实体，而不一定对应于数据库表中的一行记录（可能一个实体的数据分散保存到几个表中，也可能根本就不保存到数据库，而是保存到NoSQL、XML或其他文件中）。领域对象通过类中定义的方法封装和实现了业务领域逻辑，一个软件系统中所有领域对象的总和就包含了所有的业务逻辑、业务知识和业务规则。

因为采用面向对象的方法设计领域层，领域对象可以充分利用OO的继承、封装和多态等概念表述业务逻辑，利用策略、状态、门面等设计模式灵活处理业务变化，下面其他的博文会充分论述这一点。

###3、以领域层为中心构建软件系统。

在企业应用四层架构（基础设施层、领域层、应用层和表示层）中，领域层定义领域概念，封装业务逻辑，是整个系统的中心。它直接映射到问题域（业务领域），包含而且仅包含领域知识。它不依赖于其他任何一层，其他各层都直接或间接依赖于它。所以，应该首先设计和实现领域层，随后才设计和实现其他各层。

领域层在实现业务逻辑的过程中可能需要用到某些技术机制来提供帮助，例如持久化、消息传送等等，基础设施层为领域层的需求提供技术实现方案。

通过领域层领域对象的不同排列组合，可以实现某些专门的应用，这些专门的应用就是由应用层的对象来使用领域层的领域对象来实现的。领域层的对象是领域通用的，应用层的对象是应用特定的。 表示层将领域对象暴露给人类用户或其他计算机系统，或者从人类用户或其他计算机系统接收命令，通过应用层最终更改领域对象的状态。

与CRUD模式相比，CRUD是以数据库关系模型为中心的，软件围绕着数据的存储、呈现和转换来进行构建；而DDD是以对象模型（领域模型）为中心的，软件围绕着领域对象的关联和协作来进行构建，这是两者最大的区别。

用同一套语言来描述问题域（业务）和解决方案域（计算机软件），消除业务和软件之间的界限，业务即软件，软件即业务，这就是领域驱动设计。

代码结构：
、
实体(Entity) & 值对象(Value Object)
实体与面向对象中的概念类似，在这里再次提出是因为它是领域模型的基本元素。在领域模型中，实体应该具有唯一的标识符，从设计的一开始就应该考虑实体，决定是否建立一个实体也是十分重要的。
值对象和我们说的编程中数值类型的变量是不同的，它仅仅是没有唯一标识符的实体，比如有两个收获地址的信息完全一样，那它就是值对象，并不是实体。值对象在领域模型中是可以被共享的，他们应该是“不可变的”（只读的），当有其他地方需要用到值对象时，可以将它的副本作为参数传递。


服务(Services)
当我们在分析某一领域时，一直在尝试如何将信息转化为领域模型，但并非所有的点我们都能用Model来涵盖。对象应当有属性，状态和行为，但有时领域中有一些行为是无法映射到具体的对象中的，我们也不能强行将其放入在某一个模型对象中，而将其单独作为一个方法又没有地方，此时就需要服务.
服务是无状态的，对象是有状态的。所谓状态，就是对象的基本属性：高矮胖瘦，年轻漂亮。服务本身也是对象，但它却没有属性（只有行为），因此说是无状态的。
PS:这与我们常说的服务器的状态是两个概念，无状态的服务器是指，对服务器来说每次接收到的HTTP请求都像是客户端第一次发送的一样；而有状态的服务器就会存储客户端的状态，常见的就是Cookie&Session
服务存在的目的就是为领域提供简单的方法。为了提供大量便捷的方法，自然要关联许多领域模型，所以说，行为(Action)天生就应该存在于服务中。
服务具有以下特点：
a)服务中体现的行为一定是不属于任何实体和值对象的，但它属于领域模型的范围内
b)服务的行为一定设计其他多个对象
c)服务的操作是无状态的
PS:不要随意放置服务,如果该行为是属于应用层的，那就应该放在那；如果它为领域模型服务，那它就应该存储在领域层中，要避免业务的服务直接操作数据库，最好通过DAO。

模块(Moudles)
对于一个复杂的应用来说，领域模型将会变的越来越大，以至于很难去描述和理解，更别提模型之间的关系了。模块的出现，就是为了组织统一的模型概念来达到减少复杂性的目的的。而另一个原因则是模块可以提高代码质量和可维护性，比如我们常说的高内聚，低耦合就是要提倡将相关的类内聚在一起实现模块化。
模块应当有对外的统一接口供其他模块调用，比如有三个对象在模块a中，那么模块b不应该直接操作这三个对象，而是操作暴露的接口。模块的命名也很有讲究，最好能够深层次反映领域模型。

工厂(Factories)
在大型系统中，实体和聚合通常是很复杂的，这就导致了很难去通过构造器来创建对象。工厂就决解了这个问题，它把创建对象的细节封装起来，巧妙的实现了依赖反转。当然对聚合也适用（当建立了聚合根时，其他对象可以自动创建）。工厂最早被大家熟知可能还是在设计模式中，的确，在这里提到的工厂也是这个概念。
但是不要盲目的去应用工厂，以下场景不需要工厂：
a)构造器很简单
b)构造对象时不依赖于其他对象的创建
c)用策略模式就可以解决

仓库(Repository)
仓库封装了获取对象的逻辑，领域对象无须和底层数据库交互，它只需要从仓库中获取对象即可。仓库可以存储对象的引用，当一个对象被创建后，它可能会被存储到仓库中，那么下次就可以从仓库取。如果用户请求的数据没在仓库中，则会从数据库里取，这就减少了底层交互的次数。当然，仓库获取对象也是有策略的，如下：




2. Solid principle:

What is SOLID?
SOLID are five basic principles whichhelp to create good software architecture. SOLID is an acronym where:-

S stands for SRP (Single responsibility principle
O stands for OCP (Open closed principle)
L stands for LSP (Liskov substitution principle)
I stands for ISP ( Interface segregation principle)
D stands for DIP ( Dependency inversion principle)

S:So SRP says that a class should have only one responsibility and not multiple.
O:How about rather than “MODIFYING” we go for “EXTENSION”. In other words every time a new customer type needs to be added we create a new class as shown in the below. So whatever is the current code they are untouched and we just need to test and check the new classes.
L:A parent class object should be able to refer child objects seamlessly during runtime polymorphism.
I stands for ISP (Interface segregation principle):- Client should not be forced to use a interface if it does not need it.
D stands for DIP (Dependency inversion principle) :- High level modules should not depend on low level modules but should depend on abstraction.

S:
单一职责原则
一个类只应承担一种责任。换句话说，让一个类只做一件事。如果需要承担更多的工作，那么分解这个类。

举例
订单和账单上都有流水号、业务时间等字段。如果只用一个类表达，赋予其双重职责，后果:

特有属性和共有属性相互掺杂，难以理解;
修改一个场景可能会影响另一个场景。
正确的做法是拆成两个独立的类。

O:开放封闭原则
实体应该对扩展是开放的，对修改是封闭的。即，可扩展(extension)，不可修改(modification)。

L:
里式替换原则
一个对象在其出现的任何地方，都可以用子类实例做替换，并且不会导致程序的错误。换句话说，当子类可以在任意地方替换基类且软件功能不受影响时，这种继承关系的建模才是合理的。

I:接口分离原则
客户(client)不应被强迫依赖它不使用的方法。即，一个类实现的接口中，包含了它不需要的方法。将接口拆分成更小和更具体的接口，有助于解耦，从而更容易重构、更改。

D:依赖倒置原则
高层次的模块不应依赖低层次的模块，他们都应该依赖于抽象。
抽象不应依赖于具体实现，具体实现应依赖抽象。


6.单例模式：

1、什么是单例模式

1-1、模式理解
      保证一个类仅有一个实例，并提供一个访问它的全局访问点。
      


分布式系统：
https://medium.freecodecamp.org/a-thorough-introduction-to-distributed-systems-3b91562c9b3c

7.micro services.
framework : NServiceBus



